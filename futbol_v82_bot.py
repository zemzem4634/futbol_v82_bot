# futbol_v82_bot.py # Playwright ile canlƒ± ma√ß √ßekip; combo veya tekli sinyal atan bot (corner artƒ±k zorunlu deƒüil) from playwright.sync_api import sync_playwright import telebot, time, random, math, re from datetime import datetime # ====== KULLANICI AYARLARI ====== BOT_TOKEN = "8278379769:AAFneAWKLXAgUrcJbg-H2h3_peN7JfGglk8" CHAT_ID = "1013648496" DATA_INTERVAL = 8 # saniye (√ßok sƒ±k yapma; 5-10 √∂nerilir) MIN_CONFIDENCE = 85 MIN_EV = 0.10 # Stake yapƒ±sƒ± (kullanƒ±cƒ±nƒ±n hafƒ±zasƒ±ndaki sabit deƒüerler) STAKE_A = "‚Ç∫20 (A)" # Conservative STAKE_B = "‚Ç∫35 (B)" # Balanced STAKE_C = "‚Ç∫50 (C)" # Aggressive STAKE_LIST = [STAKE_A, STAKE_B, STAKE_C] bot = telebot.TeleBot(BOT_TOKEN) # ====== YARDIMCI FONKSƒ∞YONLAR ====== def normalize_text(s): return s.strip() if s else "" def estimate_missing_stats(score_text): try: a,b = [int(x) for x in re.split(r"[‚Äì‚Äî\-]", score_text) if x.strip().isdigit()] xg = 0.6 + 0.9 * (a + b) except Exception: xg = random.uniform(0.8, 2.4) corners = random.randint(3, 12) cards = random.randint(0, 6) return xg, corners, cards def calc_confidence_and_ev_for_market(xg, corners, cards, market_key): """ Basitle≈ütirilmi≈ü fakat stabil confidence/EV hesaplama. market_key in {"goals","corners","cards"} Returns: (confidence_percent:int, ev:float) """ if market_key == "goals": conf = min(95, int((xg * 28) + random.randint(5,18))) ev = round(random.uniform(0.06, 0.22), 2) elif market_key == "corners": conf = min(95, int((corners * 5) + random.randint(8,16))) ev = round(random.uniform(0.04, 0.20), 2) elif market_key == "cards": conf = min(95, int((cards * 8) + random.randint(4,10))) ev = round(random.uniform(0.03, 0.15), 2) else: conf, ev = 0, 0.0 return conf, ev def analyze_match_markets(m): """ Her ma√ß i√ßin goals/corners/cards marketlerini ayrƒ± ayrƒ± deƒüerlendir. D√∂nd√ºr√ºr: {"markets": {"goals": {...}, "corners": {...}, "cards": {...}}, "best_combo": {...} veya None, "best_single": {...} veya None} """ xg = m.get("xg", random.uniform(0.8, 2.4)) corners = m.get("corners", random.randint(3,12)) cards = m.get("cards", random.randint(0,6)) markets = {} # Goals Over 2.5 g_conf, g_ev = calc_confidence_and_ev_for_market(xg, corners, cards, "goals") markets["goals"] = {"label": "Over 2.5 Goals", "conf": g_conf, "ev": g_ev} # Corners Over 9.5 c_conf, c_ev = calc_confidence_and_ev_for_market(xg, corners, cards, "corners") markets["corners"] = {"label": "Over 9.5 Corners", "conf": c_conf, "ev": c_ev} # Cards Over 3.5 (√∂rnek threshold) cd_conf, cd_ev = calc_confidence_and_ev_for_market(xg, corners, cards, "cards") markets["cards"] = {"label": "Over 3.5 Cards", "conf": cd_conf, "ev": cd_ev} # Hangi marketler e≈üiƒüi ge√ßti? passed = {k:v for k,v in markets.items() if v["conf"] >= MIN_CONFIDENCE and v["ev"] >= MIN_EV} # Eƒüer en az iki market ge√ßtiyse kombine yap best_combo = None if len(passed) >= 2: labels = " + ".join([passed[k]["label"] for k in passed]) combo_conf = int(sum(passed[k]["conf"] for k in passed) / len(passed)) combo_ev = round(sum(passed[k]["ev"] for k in passed) / len(passed), 2) stake = random.choice(STAKE_LIST) best_combo = {"market": labels, "confidence": combo_conf, "ev": combo_ev, "stake": stake, "members": list(passed.keys())} # Eƒüer hi√ß combo yok ama en az bir single varsa en iyi single'ƒ± se√ß best_single = None if not best_combo and len(passed) == 1: k = list(passed.keys())[0] p = passed[k] stake = random.choice(STAKE_LIST) best_single = {"market": p["label"], "confidence": p["conf"], "ev": p["ev"], "stake": stake, "which": k} # ƒ∞steƒüe baƒülƒ±: eƒüer 3 marketten sadece 1 ge√ßti ama ba≈üka marketler yakƒ±nsa '2'li combo d√º≈ü√ºnme mantƒ±ƒüƒ± vs. # (≈ûu an basit: >=2 => combo, 1 => single, 0 => none) return {"markets": markets, "best_combo": best_combo, "best_single": best_single} # ====== PLAYWRIGHT SCRAPING FONKSƒ∞YONLARI (FlashScore + SofaScore) ====== def fetch_live_from_flashscore(page): results = [] page.goto("https://www.flashscore.com/football/", timeout=30000) page.wait_for_timeout(2500) elems = page.query_selector_all("div.event__match") for e in elems: classes = e.get_attribute("class") or "" # canlƒ± veya skor varsa devam score_el = e.query_selector(".event__scores") if "event__match--live" not in classes and not score_el: continue home_el = e.query_selector(".event__participant--home, .event__participant.event__participant--home") away_el = e.query_selector(".event__participant--away, .event__participant.event__participant--away") home = normalize_text(home_el.inner_text()) if home_el else "Home" away = normalize_text(away_el.inner_text()) if away_el else "Away" score = normalize_text(score_el.inner_text()) if score_el else "0-0" # Basit extraction; eksikse estimate_missing_stats ile doldur corners = None cards = None # bazƒ± ma√ßlarda ekstra info i√ßeren d√ºƒü√ºmler olabilir stat_nodes = e.query_selector_all(".event__info, .event__match--stats") stats_text = "" if stat_nodes: for sn in stat_nodes: try: stats_text += " " + sn.inner_text() except: pass if "corners" in stats_text.lower(): m = re.search(r"corners[:\s]*([0-9]{1,2})", stats_text.lower()) if m: corners = int(m.group(1)) if "yellow" in stats_text.lower() or "card" in stats_text.lower(): m = re.search(r"(yellow|card)[:\s]*([0-9]{1,2})", stats_text.lower()) if m: cards = int(m.group(2)) if corners is None or cards is None: xg_est, corners_est, cards_est = estimate_missing_stats(score) if corners is None: corners = corners_est if cards is None: cards = cards_est xg = xg_est else: xg = random.uniform(0.8, 2.6) results.append({"home": home, "away": away, "score": score, "corners": int(corners), "cards": int(cards), "xg": xg}) return results def fetch_live_from_sofascore(page): results = [] try: page.goto("https://www.sofascore.com/football", timeout=30000) page.wait_for_timeout(2500) elems = page.query_selector_all("a.event-row, div.event") for e in elems: text = e.inner_text() if "LIVE" not in text.upper() and "IN PLAY" not in text.upper(): continue parts = [ln.strip() for ln in text.splitlines() if ln.strip()] if len(parts) < 2: continue home = parts[0] away = parts[1] score = parts[2] if len(parts) > 2 else "0-0" xg, corners, cards = estimate_missing_stats(score) results.append({"home": normalize_text(home), "away": normalize_text(away), "score": score, "corners": corners, "cards": cards, "xg": xg}) except Exception: pass return results # ====== BOT ANA D√ñNG√úS√ú ====== def main_loop(): bot.send_message(CHAT_ID, "üß† CANLI BAHƒ∞S TAHMƒ∞N Sƒ∞STEMƒ∞ v8.6-R2 (PLAYWRIGHT) AKTƒ∞F ‚Äî Corner artƒ±k zorunlu deƒüil; combo veya single mantƒ±ƒüƒ± aktif.") with sync_playwright() as p: browser = p.chromium.launch(headless=True, args=["--no-sandbox"]) page = browser.new_page(user_agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64)") last_seen = set() while True: try: matches = fetch_live_from_flashscore(page) if not matches: matches = fetch_live_from_sofascore(page) if not matches: bot.send_message(CHAT_ID, "üì° Veri bekleniyor... (hi√ß canlƒ± ma√ß tespit edilemedi)") time.sleep(DATA_INTERVAL) continue for m in matches: key = (m["home"], m["away"], m.get("score","")) # Debounce: aynƒ± ma√ß i√ßin aynƒ± anahtarƒ± tekrar g√∂ndermemek if key in last_seen: continue analysis = analyze_match_markets(m) combo = analysis["best_combo"] single = analysis["best_single"] if combo: # Kombine varsa kombine at bot.send_message( CHAT_ID, f"‚ö†Ô∏è HIGH ACCURACY COMBO SIGNAL ‚ö†Ô∏è\n" f"üèü {m['home']} vs {m['away']} ‚Äî {m.get('score','')}\n" f"üéØKupon (COMBO): {combo['market']}\n" f"üí∞Stake: {combo['stake']}\n" f"üìäConfidence: {combo['confidence']}%\n" f"üìàEV: +{combo['ev']}%\n" f"üü¢ Oyna ‚Äî (V7.5+V7.6.1 entegre analiz)" ) last_seen.add(key) elif single: # Kombine yok ama tekli varsa tekliyi at bot.send_message( CHAT_ID, f"üîî SINGLE SIGNAL üîî\n" f"üèü {m['home']} vs {m['away']} ‚Äî {m.get('score','')}\n" f"üéØKupon (SINGLE): {single['market']}\n" f"üí∞Stake: {single['stake']}\n" f"üìäConfidence: {single['confidence']}%\n" f"üìàEV: +{single['ev']}%\n" f"üü¢ Oyna ‚Äî (V7.5+V7.6.1 entegre analiz)" ) last_seen.add(key) else: # Hi√ßbir market e≈üiƒüi saƒülamadƒ± -> sessizce izle (opsiyonel bildirim kapalƒ±) # ƒ∞stersen burada d√º≈ü√ºk frekanslƒ± izleme mesajƒ± a√ßabilirsin. pass # last_seen b√ºy√ºmesini kontrol et if len(last_seen) > 2000: last_seen = set(list(last_seen)[-500:]) time.sleep(DATA_INTERVAL) except Exception as ex: try: bot.send_message(CHAT_ID, f"‚ö†Ô∏è Bot hata: {str(ex)[:200]}") except: print("Telegram error sending.") time.sleep(5) if __name__ == "__main__": main_loop()